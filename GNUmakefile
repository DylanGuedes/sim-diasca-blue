.PHONY: help help-traces                                              \
	all all-pre-hook-local prerequisites rebuild generate-all-plt     \
	generate-list-of-all-types link-host-candidates                   \
	check-hook check-hook-local full-check plt-check                  \
	release release-zip release-bz2 release-doc prepare-release       \
	clean-release clean clean-prerequisites clean-generated-files     \
	clean-all-results real-clean real-clean-local                     \
	install to-archive to-archive-full vcs-archive archive            \
	update-third-party-mirror release stats                           \
	info info-files info-local-files info-paths info-build            \
	info-archive info-version info-release


# Root of the Sim-Diasca based software stack (absolute paths are preferred):
ROOT_TOP := .
#ROOT_TOP := $(PWD)


# Allows to strictly build a layer before the above one (hence it is a bottom-up
# sequential build), while each layer is internally built in parallel:

# Marks this makefile as the root one (hence different rules may apply):
ROOT_MAKEFILE = true

# We are not at the base of a layer here:
BASE_MAKEFILE = false


# As layers form a chain, we only have to specify where the one just below the
# current one is:
#
#COMMON_TOP            := $(ROOT_TOP)/common
#WOOPER_TOP            := $(ROOT_TOP)/wooper
#TRACES_TOP            := $(ROOT_TOP)/traces
#SIM_DIASCA_TOP        := $(ROOT_TOP)/sim-diasca
MOCK_SIMULATORS_TOP    := $(ROOT_TOP)/mock-simulators
SUSTAINABLE_CITIES_TOP := $(ROOT_TOP)/sustainable-cities




PREREQUISITES_DIRS = $(COMMON_TOP) $(WOOPER_TOP) $(TRACES_TOP)


# Directories not to be distributed in the free software releases:
#
NON_DISTRIBUTED_DIRS := $(SUSTAINABLE_CITIES_TOP)


# Allow for conditional rules:

HAS_SUSTAINABLE_CITIES := $$( if [ -d $(SUSTAINABLE_CITIES_TOP) ] ; \
	then echo "true" ; else echo "false" ; fi )



# Modules which will be built iff they are available on this distribution:
#
OPTIONAL_MODULES_DIRS := $$( for d in $(NON_DISTRIBUTED_DIRS) ; do \
	 if [ -d $$d ] ; then echo $$d ; fi ; done )


# 'Common', 'WOOPER', 'Traces' not listed anymore here, as deemed to be external
# prerequisites.
# 'applications' not listed anymore here, as deemed to be only Sim-Diasca using
# code.
#
MODULES_DIRS = $(PREREQUISITES_DIRS) $(SIM_DIASCA_TOP) $(MOCK_SIMULATORS_TOP) \
			   $(OPTIONAL_MODULES_DIRS)


# We ought to install the tool base, not its related examples (knowing that
# moreover mock-simulators and sustainable-cities would each centralise all the
# BEAMs from their various cases in a single location, leading to name clashes;
# ex: class_City.beam)
#
INSTALLED_DIRS = $(PREREQUISITES_DIRS) $(SIM_DIASCA_TOP)


# For all standalone applications in Mock Simulators:
MOCK_DIRS = $(MOCK_SIMULATORS_TOP)/soda-test    \
			$(MOCK_SIMULATORS_TOP)/ssi-test     \
			$(MOCK_SIMULATORS_TOP)/city-example



# So that for example the archive file is named correspondingly:
PROJECT_NAME = Sim-Diasca


# We do not want to include the 'mock-simulators' directory here as such, as we
# have to include directly some of its subdirectories instead:
#
PLT_TARGETS = $(PREREQUISITES_DIRS) $(SIM_DIASCA_TOP) $(MOCK_DIRS)


# Default target:
help: help-intro help-root


include $(ROOT_TOP)/GNUmakesettings.inc



help-intro:
	@echo " Following main make targets are available from this root of the Sim-Diasca code base:"
	@echo "  - 'rebuild':       cleans, builds and generates list of all types"
	@echo "  - 'release':       generates a source release for the $(SIM_DIASCA_VERSION) version "
	@echo "  - 'release-doc':   generates a documentation package for the $(SIM_DIASCA_VERSION) version "


help-root:
	@cd $(SIM_DIASCA_TOP) && $(MAKE) -s help-sim-diasca


# Ensures that the package version file is, if needed, recreated first:
#
all-recurse-pre-hook: $(VERSION_FILE)


# No generic 'register-version-in-header' target can be defined, as the Erlang
# defines may be arbitrarily defined by each layer.
#
# Do not use 'echo -e' here, a faulty header would be generated.
#
$(VERSION_FILE):
	@echo "   Generating the header file collecting all package versions " \
	"($$(basename $(VERSION_FILE)))"
	@echo "% Header automatically generated by the 'all-pre-hook'"  > $(VERSION_FILE)
	@echo "% make target." >> $(VERSION_FILE)
	@echo "" >> $(VERSION_FILE)
	@for m in $(MODULES_DIRS); do ( cd $$m && $(MAKE) -s \
	register-version-in-header VERSION_FILE=$(PWD)/$(VERSION_FILE) ); done


prerequisites:
	@echo "   Making prerequisites: $(PREREQUISITES_DESCRIPTION)"
	@for m in $(PREREQUISITES_DIRS); do if ! ( if [ -d $$m ] ; then cd $$m && \
	$(MAKE) -s all && cd .. ;                                                 \
	else echo "     (non-existing directory $$m skipped)" ; fi ) ; then       \
	exit 1; fi ; done


rebuild: clean all generate-list-of-all-types


generate-all-plt: all
	@echo "   Generating now PLTs for the full Sim-Diasca based stack:"
	@for m in $(PLT_TARGETS) ; do \
	( cd $$m ; $(MAKE) -s generate-local-plt ) ; done


generate-list-of-all-types:
	@echo "   Listing now all types defined in the full Sim-Diasca based stack:"
	@for m in $(PLT_TARGETS) ; do \
	( cd $$m ; $(MAKE) -s generate-list-of-local-types ) ; done


# Creates all relevant links in the source tree to the central, single, host
# candidate configuration file:
#
link-host-candidates:
	@echo "   Creating symbolic links to $(SIM_DIASCA_HOST_FILE) \
	in the full source tree"
	@for f in $(SIM_DIASCA_TOP) $(MOCK_SIMULATORS_TOP) ; do \
	( cd $$f && $(MAKE) -s make-config-links-recurse ) ; done



check-hook: check-hook-local


check-hook-local:
	@echo "   One should run 'make full-check' from this root instead." 1>&2
	@exit 5


# 'check' would not suffice as we want to rebuild also prerequisites:
full-check: rebuild
	@echo "   Performing now a full check (tests + static analyses) of \
	the Sim-Diasca based stack:"
	@for m in $(PLT_TARGETS); do \
	( cd $$m ; $(MAKE) -s test generate-local-plt self-check-against-plt ) ; \
	done


plt-check: all
	@echo "   Performing now a static analysis for each layer of \
	the Sim-Diasca based stack (with no forced rebuild):"
	@for m in $(PLT_TARGETS); do \
	( cd $$m ; $(MAKE) -s generate-local-plt self-check-against-plt ) ; \
	done


doc:
	@for m in $(SIM_DIASCA_TOP) $(MOCK_DIRS); do \
	( cd $$m ; $(MAKE) -s doc ) ; done


# Release section.


release: release-zip release-bz2 #release-doc
	@$(MAKE) clean-release


release-zip: prepare-release
	@echo "     Creating Sim-Diasca release archive \
	$(SIM_DIASCA_RELEASE_ARCHIVE_ZIP)"
	@cd .. && zip -r $(SIM_DIASCA_RELEASE_ARCHIVE_ZIP) \
	$(SIM_DIASCA_RELEASE_BASENAME) \
	&& echo "     Archive $(SIM_DIASCA_RELEASE_ARCHIVE_ZIP) ready in $$(pwd)"


release-bz2: prepare-release
	@echo "     Creating Sim-Diasca release archive \
	$(SIM_DIASCA_RELEASE_ARCHIVE_BZ2)"
	@cd .. && tar chvjf $(SIM_DIASCA_RELEASE_ARCHIVE_BZ2) \
	$(SIM_DIASCA_RELEASE_BASENAME) \
	&& echo "     Archive $(SIM_DIASCA_RELEASE_ARCHIVE_BZ2) ready in $$(pwd)"


release-doc:
	@cd $(SIM_DIASCA_TOP)/doc && $(MAKE) doc-package



HOST_SAMPLE_PATH := sim-diasca/conf
HOST_SAMPLE_FILE := $(HOST_SAMPLE_PATH)/sim-diasca-host-candidates-sample.txt



# The '-L' option with cp is used so that symbolic links are replaced by their
# actual target file, otherwise tar would include dead links in releases.
#
prepare-release: real-clean clean-release
	@echo "     Preparing release archive for Sim-Diasca $(SIM_DIASCA_VERSION)"
	-@cd .. && /bin/rm -f $(SIM_DIASCA_RELEASE_ARCHIVE_ZIP) \
	$(SIM_DIASCA_RELEASE_ARCHIVE_BZ2)
	@mkdir -p $(SIM_DIASCA_RELEASE_BASE) && \
	/bin/cp -L -r $(SIM_DIASCA_PACKAGE_ELEMENTS) $(SIM_DIASCA_RELEASE_BASE)
	@/bin/rm -rf $(SIM_DIASCA_RELEASE_BASE)/sim-diasca/src/core/src/dataflow/bindings/python/src/sim-diasca-dataflow-env
	-@cd .. && find $(SIM_DIASCA_RELEASE_BASENAME) -type d -a -name '.git' \
	-exec /bin/rm -rf '{}' ';' 2>/dev/null || true
	-@cd ../$(SIM_DIASCA_RELEASE_BASENAME) && /bin/rm -f .gitignore
	-@cd .. && find $(SIM_DIASCA_RELEASE_BASENAME) -type f -a              \
	\( -name '*.beam' -o -name 'sim-diasca-host-candidates*.txt'           \
	-o -name '*.png' -o -name 'erl_crash.dump' -o -name '*.dia~' \) -exec /bin/rm -f '{}' ';' 2>/dev/null || true
	-@/bin/cp -f $(HOST_SAMPLE_FILE) \
	../$(SIM_DIASCA_RELEASE_BASENAME)/$(HOST_SAMPLE_PATH)
	-@cat sim-diasca/README.txt.template | sed -s "s|SIM_DIASCA_VERSION|$(SIM_DIASCA_VERSION)|g" > $(SIM_DIASCA_RELEASE_BASE)/README.txt



clean-release:
	@echo "     Cleaning any past release archive"
	-@cd .. && /bin/rm -rf $(SIM_DIASCA_RELEASE_BASENAME)


clean: clean-generated-files clean-all-results


clean-prerequisites:
	@echo "   Cleaning all prerequisites first"
	@for m in $(PREREQUISITES_DIRS); do if ! ( if [ -d $$m ] ; then cd $$m && \
	echo "   Cleaning prerequisite '$$(basename $$m)'" ;                       \
	$(MAKE) -s clean && cd .. ;                                               \
	else echo "     (non-existing directory $$m skipped)" ; fi ) ;            \
	then exit 1; fi ; done


clean-generated-files:
	@echo "   Cleaning all (non-BEAM) generated files"
	-@for top in $(PLT_TARGETS) ; do \
	/bin/rm -f $$top/*.plt $$top/declared-types-in-*.txt ; done
	-@cd sim-diasca/doc ; /bin/rm -f Sim-Diasca-*-doc.tar.bz2 \
	Sim-Diasca-*-doc.zip
	-@/bin/rm -f $(VERSION_FILE)
	-@find $(ROOT_TOP) -type d -a -name 'tmp-rst' -exec /bin/rm -rf '{}' ';' \
	 2>/dev/null || true


clean-all-results:
	@echo "   Cleaning recursively all results from $$(pwd)"
	-@find . -name "*-on-*-*-*-at-*h-*m-*s-by-$$USER-*" \
		-exec /bin/rm -rf '{}' 2>/dev/null ';' || true


real-clean: real-clean-local


real-clean-local:
	@cd $(SIM_DIASCA_TOP) && $(MAKE) -s clean-host-candidate-files
	@cd $(MOCK_SIMULATORS_TOP) && $(MAKE) -s clean-host-candidate-files


# In the current process we do not use this 'install' target.
#
# (target 'all' implied by generic rules)
#
install:
	@echo "   Installing all in $(INSTALLATION_PREFIX), from $$(basename $(PWD))"
	@for m in $(INSTALLED_DIRS); do if ! ( if [ -d $$m ] ; then cd $$m && \
	$(MAKE) -s install-package INSTALLATION_PREFIX="$(INSTALLATION_PREFIX)" &&  \
	cd .. ; else echo "     (directory $$m skipped)" ; fi ) ;           \
	then exit 1; fi ; done && \
	echo " The full Sim-Diasca code base has been successfully installed in '$(INSTALLATION_PREFIX)'."


# Includes all the first-level prerequisites, only with the files in VCS:
to-vcs-archive: vcs-archive
	@echo "    Transferring VCS archive $(VCS_ARCHIVE_FILE) to $(ARCHIVE_SERVER)"
	@scp $(VCS_ARCHIVE_FILE) $(ARCHIVE_LOCATION)


# Sends full content to the server:
to-archive: archive
	@echo "    Transferring full archive $(ARCHIVE_FILE) to $(ARCHIVE_SERVER)"
	@scp $(ARCHIVE_FILE) $(ARCHIVE_LOCATION)



# Notes:
#
# - unlike the former bz2 target with SVN, here the non-staged files are *not*
# archived (use 'make archive' for that)
#
# - 'git bundle' is already sufficiently compressed (no need for a *.bz2 or a
# *.xz)
#
vcs-archive: clean
	@echo "    Making a VCS archive (bundle) of the full Sim-Diasca repository"
	@echo "(to retrieve that archive content, use 'git clone $(VCS_ARCHIVE_FILE)' and then 'git remote set-url origin <authoritative URL>'); note that uncommitted changes and files in the working tree will NOT be included in that archive (use 'make archive' for that)"
	@git bundle create $(VCS_ARCHIVE_FILE) --all \
	&& echo "Full Sim-Diasca VCS archive stored in $(VCS_ARCHIVE_FILE)"



# Brutal archive of the current branch, including all untracked files:
archive: clean
	@echo "    Making an archive of the Sim-Diasca-specific repository \
	(including all files and directories in their current state, \
	and VCS information)"
	@mkdir -p $(ARCHIVE_ROOT) ; SRC_DIR=$(basename $(PWD)) ; \
	cd $(ROOT_TOP)/.. && tar cvJf $(ARCHIVE_FILE) $$SRC_DIR
	@echo && echo "Sim-Diasca full archive stored in $(ARCHIVE_FILE)"




# To update the mirror of a third-party project with this current
# branch of the Sim-Diasca sources:

THIRD_PARTY_ROOT="$$HOME/Projects/RELEASE"

THIRD_PARTY_SYNC_TARGET="$(THIRD_PARTY_ROOT)/github-repository/RELEASE/Research/Benchmarks/sim-diasca-benchmark-target/sim-diasca-latest"

update-third-party-mirror:
	@sim-diasca/conf/update-third-party-repository-from-tree.sh . $(THIRD_PARTY_SYNC_TARGET)



stats:
	@$(MAKE_CODE_STATS) $(PWD)


info: info-files info-paths info-archive info-release


info-files: info-local-files


info-local-files:
	@echo "VERSION_FILE = $(VERSION_FILE)"


info-paths:
	@echo "ROOT_TOP               = $(ROOT_TOP)"
	@echo "COMMON_TOP             = $(COMMON_TOP)"
	@echo "WOOPER_TOP             = $(WOOPER_TOP)"
	@echo "TRACES_TOP             = $(TRACES_TOP)"
	@echo "SIM_DIASCA_TOP         = $(SIM_DIASCA_TOP)"
	@echo "MOCK_SIMULATORS_TOP    = $(MOCK_SIMULATORS_TOP)"
	@echo "SUSTAINABLE_CITIES_TOP = $(SUSTAINABLE_CITIES_TOP)"
	@echo "PLT_TARGETS            = $(PLT_TARGETS)"


info-build:
	@echo "MODULES_DIRS = $(MODULES_DIRS)"
	@echo "HAS_SUSTAINABLE_CITIES = $(HAS_SUSTAINABLE_CITIES)"
	@echo "USE_HDF5 = $(USE_HDF5)"
	@echo "USE_REST = $(USE_REST)"


info-archive:
	@echo "ARCHIVE_ROOT        = $(ARCHIVE_ROOT)"
	@echo "ARCHIVE_SERVER      = $(ARCHIVE_SERVER)"
	@echo "ARCHIVE_LOCATION    = $(ARCHIVE_LOCATION)"
	@echo "ARCHIVE_FILE        = $(ARCHIVE_FILE)"
	@echo "ARCHIVE_BRANCH_FILE = $(ARCHIVE_BRANCH_FILE)"


info-version:
	@echo "This is Sim-Diasca version $(SIM_DIASCA_VERSION)."


info-release:
	@echo "SIM_DIASCA_RELEASE_BASENAME    = $(SIM_DIASCA_RELEASE_BASENAME)"
	@echo "SIM_DIASCA_RELEASE_BASE        = $(SIM_DIASCA_RELEASE_BASE)"
	@echo "SIM_DIASCA_PACKAGE_ELEMENTS    = $(SIM_DIASCA_PACKAGE_ELEMENTS)"
	@echo "SIM_DIASCA_RELEASE_ARCHIVE_ZIP = $(SIM_DIASCA_RELEASE_ARCHIVE_ZIP)"
	@echo "SIM_DIASCA_RELEASE_ARCHIVE_BZ2 = $(SIM_DIASCA_RELEASE_ARCHIVE_BZ2)"
	@echo "SIM_DIASCA_RELEASE_ARCHIVE_XZ  = $(SIM_DIASCA_RELEASE_ARCHIVE_XZ)"
